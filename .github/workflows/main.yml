name: SarvCast Backend Deploy

on:
  push:
    branches:
      - main

env:
  FTP_SERVER: "ftp.sarvcast.ir"
  FTP_USERNAME: "my@sarvcast.ir"
  FTP_PASSWORD: "Prof48017421@#"
  SITE_URL: "https://my.sarvcast.ir"
  DEPLOY_TOKEN: "sarvcast_deploy_key_2026"
  TELEGRAM_BOT_TOKEN: "7488407974:AAFl4Ek9IanbvlkKlRoikQAqdkDtFYbD0Gc"
  TELEGRAM_CHAT_ID: "-1002796302613_97"

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: 8.2

      - name: Cache Composer packages
        uses: actions/cache@v3
        with:
          path: vendor
          key: ${{ runner.os }}-php-${{ hashFiles('**/composer.lock') }}
          restore-keys: |
            ${{ runner.os }}-php-

      - name: Install dependencies
        run: composer install --no-dev --optimize-autoloader --no-interaction

      - name: Prepare deployment
        run: |
          chmod -R 777 storage bootstrap/cache

          # Create the deploy/extract script that will live on the server
          cat > _deploy_extract.php << 'EXTRACTSCRIPT'
          <?php
          if (($_GET['token'] ?? '') !== 'sarvcast_deploy_key_2026') {
              http_response_code(403);
              die(json_encode(['error' => 'Unauthorized']));
          }

          @ini_set('memory_limit', '512M');
          set_time_limit(600);

          $results = [];
          $baseDir = __DIR__;
          $zipFile = $baseDir . '/_deploy_package.zip';

          if (!file_exists($zipFile)) {
              header('Content-Type: application/json');
              echo json_encode(['success' => false, 'results' => ['No zip file found']]);
              exit;
          }

          $zipSize = filesize($zipFile);
          $results[] = 'Zip size: ' . round($zipSize / 1024 / 1024, 2) . ' MB';

          $extracted = false;

          // Method 1: shell unzip (fastest, no PHP memory issues)
          if (!$extracted && function_exists('exec')) {
              $output = [];
              $code = -1;
              @exec('cd ' . escapeshellarg($baseDir) . ' && unzip -o ' . escapeshellarg($zipFile) . ' 2>&1', $output, $code);
              if ($code === 0) {
                  $extracted = true;
                  $results[] = 'Extracted via exec(unzip)';
              } else {
                  $results[] = 'exec(unzip) failed (code ' . $code . '): ' . implode(' ', array_slice($output, -3));
              }
          }

          // Method 2: shell_exec unzip
          if (!$extracted && function_exists('shell_exec')) {
              $out = @shell_exec('cd ' . escapeshellarg($baseDir) . ' && unzip -o ' . escapeshellarg($zipFile) . ' 2>&1');
              if ($out !== null && stripos($out, 'error') === false) {
                  $extracted = true;
                  $results[] = 'Extracted via shell_exec(unzip)';
              } else {
                  $results[] = 'shell_exec(unzip) failed: ' . substr($out ?? 'null', -200);
              }
          }

          // Method 3: ZipArchive with high memory
          if (!$extracted && class_exists('ZipArchive')) {
              $zip = new ZipArchive();
              if ($zip->open($zipFile) === true) {
                  $numFiles = $zip->numFiles;
                  $results[] = 'ZipArchive opened: ' . $numFiles . ' files';
                  if ($zip->extractTo($baseDir . '/')) {
                      $extracted = true;
                      $results[] = 'Extracted via ZipArchive';
                  } else {
                      $results[] = 'ERROR: ZipArchive extractTo() returned false';
                  }
                  $zip->close();
              } else {
                  $results[] = 'ERROR: ZipArchive could not open zip';
              }
          }

          if ($extracted) {
              @unlink($zipFile);
              $results[] = 'Zip file removed';

              // Verify critical files exist
              $checks = ['vendor/autoload.php', 'artisan', 'public/index.php',
                         'vendor/laravel/framework/src/Illuminate/Foundation/Application.php'];
              foreach ($checks as $f) {
                  $results[] = file_exists($baseDir . '/' . $f) ? "OK: $f" : "MISSING: $f";
              }
          } else {
              $results[] = 'ERROR: All extraction methods failed!';
              header('Content-Type: application/json');
              http_response_code(500);
              echo json_encode(['success' => false, 'results' => $results], JSON_PRETTY_PRINT);
              exit;
          }

          // Storage symlink
          $publicDir = $baseDir . '/public';
          $link = $publicDir . '/storage';
          $target = $baseDir . '/storage/app/public';
          if (is_link($link)) {
              $results[] = 'Storage symlink already exists';
          } elseif (!file_exists($link)) {
              if (@symlink($target, $link)) {
                  $results[] = 'Storage symlink created';
              } else {
                  @mkdir($link, 0755, true);
                  file_put_contents($link . '/.htaccess',
                      "RewriteEngine On\nRewriteRule ^(.*)$ /storage/app/public/$1 [L]");
                  $results[] = 'Created .htaccess redirect as symlink fallback';
              }
          }

          // Ensure directories exist
          foreach ([
              $baseDir . '/storage/app/public',
              $baseDir . '/storage/framework/cache/data',
              $baseDir . '/storage/framework/sessions',
              $baseDir . '/storage/framework/views',
              $baseDir . '/storage/logs',
              $baseDir . '/bootstrap/cache',
          ] as $dir) {
              if (!is_dir($dir)) { @mkdir($dir, 0755, true); $results[] = "Created: $dir"; }
          }

          foreach (['images/categories','images/stories','images/episodes',
                     'images/people','images/users','images/playlists','images/timeline'] as $d) {
              $p = $publicDir . '/' . $d;
              if (!is_dir($p)) { @mkdir($p, 0755, true); $results[] = "Created: public/$d"; }
          }

          @unlink(__FILE__);
          $results[] = 'Deploy script removed';

          header('Content-Type: application/json');
          echo json_encode(['success' => true, 'results' => $results], JSON_PRETTY_PRINT);
          EXTRACTSCRIPT

      - name: Create deployment zip
        run: |
          echo "Creating deployment zip..."
          zip -r -q _deploy_package.zip . \
            -x ".git/*" \
            -x ".github/*" \
            -x ".env" \
            -x ".env.*" \
            -x "tests/*" \
            -x "phpunit.xml" \
            -x ".styleci.yml" \
            -x "node_modules/*" \
            -x "storage/logs/*.log" \
            -x "storage/framework/sessions/*" \
            -x "storage/framework/views/*.php" \
            -x "_deploy_extract.php" \
            -x "_deploy_package.zip"

          ZIP_SIZE=$(du -h _deploy_package.zip | cut -f1)
          echo "Zip created: $ZIP_SIZE"

      - name: Upload zip + extractor via FTP
        run: |
          sudo apt-get update -qq && sudo apt-get install -y -qq lftp > /dev/null 2>&1

          echo "Uploading deployment zip and extractor..."

          lftp -c "
            set ftp:ssl-allow no;
            set net:timeout 120;
            set net:max-retries 5;
            set net:reconnect-interval-base 5;
            set ftp:passive-mode yes;

            open -u ${{ env.FTP_USERNAME }},'${{ env.FTP_PASSWORD }}' ${{ env.FTP_SERVER }};

            put _deploy_extract.php;
            put _deploy_package.zip;

            bye;
          "

          echo "Upload completed"

      - name: Extract on server and setup storage
        run: |
          echo "Calling deploy extractor on server..."

          RESPONSE=$(curl -s -w "\n%{http_code}" \
            "${{ env.SITE_URL }}/_deploy_extract.php?token=${{ env.DEPLOY_TOKEN }}" \
            --max-time 300)

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | head -n -1)

          echo "HTTP Status: $HTTP_CODE"
          echo "Response: $BODY"

          if [ "$HTTP_CODE" = "200" ]; then
            echo "Deployment completed successfully!"
          else
            echo "WARNING: Server returned $HTTP_CODE"
            exit 1
          fi

      - name: Notify Telegram
        if: always()
        run: |
          STATUS="${{ job.status }}"
          if [ "$STATUS" = "success" ]; then
            EMOJI="✅"
            STATUS_TEXT="Deployment Complete"
          else
            EMOJI="❌"
            STATUS_TEXT="Deployment Failed"
          fi

          COMMIT_MESSAGE="${{ github.event.head_commit.message }}"
          FORMATTED=$(echo "${COMMIT_MESSAGE}" | sed 's/$/\\n/' | sed ':a;N;$!ba;s/\n/\\n/g')
          MESSAGE=$(echo -e "${EMOJI} <b>SarvCast Backend</b> ${EMOJI}\n\n<b>Status:</b> ${STATUS_TEXT}\n<b>User:</b> ${{ github.actor }}\n<blockquote>${FORMATTED}</blockquote>")

          curl -s -X POST "https://api.telegram.org/bot${{ env.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d chat_id="${{ env.TELEGRAM_CHAT_ID }}" \
            -d text="${MESSAGE}" \
            -d parse_mode="HTML" || echo "Telegram notification failed"
